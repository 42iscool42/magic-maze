/******/ (function(modules, runtime) { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/
/******/ 	// the startup function
/******/ 	function startup() {
/******/ 		// Load entry module and return exports
/******/ 		return __webpack_require__("./src/client/create/js/main.js");
/******/ 	};
/******/
/******/ 	// run startup
/******/ 	return startup();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/client/create/js/main.js":
/*!**************************************!*\
  !*** ./src/client/create/js/main.js ***!
  \**************************************/
/*! other exports [maybe provided (runtime-defined)] [no usage info] */
/*! runtime requirements:  */
/***/ (function() {

eval("const config = {\n    size: 100,\n    tolerance: 4,\n    colors: {\n        green: '#57bd6a',\n        orange: '#e87b1a',\n        purple: '#961c91',\n        yellow: '#f7dc0a'\n    }\n}\n\nlet canvas;\nlet tile;\nlet tool = 'wall'; // wall, enter, gate, vortex\nlet color = 'green';\nlet p1 = false;\nlet p2 = false;\n\nfunction setup() {\n    canvas = createCanvas(500, 500);\n    tile = new Tile();\n}\n\nfunction draw() {\n    background('255');\n    translate(width / 2 - config.size * 2, height / 2 - config.size * 2);\n\n    // Background grid\n    grid();\n\n    // Display tile\n    tile.display();\n}\n\nfunction mousePressed() {\n    const mouseCell = getHoveredCell();\n    if (!mouseCell) return;\n    const cell = tile.layout[mouseCell.x][mouseCell.y];\n    const x = cell.coord.x;\n    const y = cell.coord.y;\n\n    if (tool === 'wall' || tool === 'wall-orange') {\n        const side = getHoveredSide(mouseCell);\n        if (!side) return;\n        let state = cell.walls[side];\n\n        if (tool === 'wall-orange') {\n            if (state === true || state === false) {\n                state = 'orange';\n            } else if (state === 'orange') {\n                state = false;\n            }\n        } else {\n            if (state === 'orange') {\n                state = true\n            } else {\n                state = !state;\n            }\n        }\n\n        // Add/remove wall\n        cell.walls[side] = state;\n\n\n        // Add/remove same wall to neighbour cell\n        if (side === 'top' && tile.layout[x][y - 1]) {\n            tile.layout[x][y - 1].walls.bottom = state;\n        } else if (side === 'right' && tile.layout[x + 1]) {\n            tile.layout[x + 1][y].walls.left = state;\n        } else if (side === 'bottom' && tile.layout[x][y + 1]) {\n            tile.layout[x][y + 1].walls.top = state;\n        } else if (side === 'left' && tile.layout[x - 1]) {\n            tile.layout[x - 1][y].walls.right = state;\n        }\n    } else if (tool === 'escalator') {\n        if (!p1) {\n            p1 = {x: x, y: y};\n        } else if (!p2) {\n            // Escalator can't go to same cell\n            if (x === p1.x && y === p1.y) return;\n\n            p2 = {x: x, y: y};\n\n            tile.layout[p1.x][p1.y].escalator = {x: p2.x, y: p2.y};\n            tile.layout[p2.x][p2.y].escalator = {x: p1.x, y: p1.y};\n        } else {\n            if (tile.layout[x][y].escalator) {\n                // Clicked on a cell with an escalator, remove it\n                const _x = tile.layout[x][y].escalator.x;\n                const _y = tile.layout[x][y].escalator.y;\n                tile.layout[_x][_y].escalator = false;\n                tile.layout[x][y].escalator = false;\n            } else {\n                p1 = {x: x, y: y};\n                p2 = false;\n            }\n        }\n    } else {\n        // Enter, gate, vortex, exit, time, crystal ball and camera\n\n        // Remove item\n        if (cell.item && cell.item.type === tool && (['time', 'enter', 'crystal', 'camera'].indexOf(tool) > -1 || cell.item.color === color)) {\n            cell.item = false;\n            return;\n        }\n\n        // gates have only four possible cells to be set on\n        if (tool === 'gate' || tool === 'enter') {\n            if (!(\n                (x === 0 && y === 1) ||\n                (x === 1 && y === 3) ||\n                (x === 2 && y === 0) ||\n                (x === 3 && y === 2)\n            )) return;\n        }\n\n        // Exits too but not the same\n        if (tool === 'exit') {\n            if (!(\n                (x === 0 && y === 0) ||\n                (x === 0 && y === 3) ||\n                (x === 3 && y === 0) ||\n                (x === 3 && y === 3)\n            )) return;\n        }\n\n        // All gates and vortexes should have a color\n        if ((tool === 'gate' || tool === 'vortex') && !color) return;\n\n        // Time, enter, crystal and camera have no color\n        if (tool === 'time' || tool === 'enter' || tool === 'crystal' || tool === 'camera') {\n            cell.item = {\n                'type': tool\n            }\n        } else {\n            cell.item = {\n                'type': tool,\n                'color': color\n            }\n        }\n    }\n}\n\nclass Tile {\n    constructor(id) {\n        this.x = 0;\n        this.y = 0;\n        this.layout = {};\n\n        for (let i = 0; i < 4; i += 1) {\n            this.layout[i] = {};\n\n            for (let j = 0; j < 4; j += 1) {\n                this.layout[i][j] = new Cell(i, j);\n            }\n        }\n    }\n\n    display() {\n        fill('#f5faff');\n\n        for (let i = 0; i < 4; i += 1) {\n            for (let j = 0; j < 4; j += 1) {\n                // For each cell\n                const cell = this.layout[i][j];\n\n                push();\n                translate(i * config.size, j * config.size);\n\n                // Draw basic grid\n                blendMode(MULTIPLY);\n                stroke(240);\n                strokeWeight(2);\n                rect(0, 0, config.size, config.size);\n\n                stroke(0);\n\n                // Add item to cell\n                let item = cell.item;\n                if (item) {\n                    if (item.type === 'vortex') {\n                        fill(config.colors[item.color]);\n                        noStroke();\n                        ellipse(config.size/2, config.size/2, config.size/2, config.size/2);\n                        stroke(0);\n                    } else if (item.type === 'article') {\n                        noStroke();\n                        fill(config.colors[item.color]);\n                        star(config.size / 2, config.size / 2, 10, 25, 5);\n                    } else if (item.type === 'crystal') {\n                        stroke(config.colors['purple']);\n                        star(config.size / 2, config.size / 2, 28, 32, 20);\n                    } else if (item.type === 'camera') {\n                        stroke(0, 0, 0);\n                        fill(255, 200, 0);\n                        polygon(config.size / 2, config.size / 2, 32, 6);\n                    } else if (item.type === 'gate' || item.type === 'enter' || item.type === 'exit') {\n                        // Set color (for gate & exit)\n                        if (config.colors[item.color]) {\n                            fill(config.colors[item.color]);\n                            stroke(config.colors[item.color]);\n                        }\n\n                        if (j === 0 && i < 3) {\n                            arrow(item.type);\n                        } else if (j === 3 && i > 0) {\n                            push();\n                            rotate(PI);\n                            translate(-config.size, -config.size);\n                            arrow(item.type);\n                            pop();\n                        } else if (i === 0) {\n                            push();\n                            translate(0, config.size);\n                            rotate(-PI/2);\n                            arrow(item.type);\n                            pop();\n                        } else if (i === 3) {\n                            push();\n                            translate(config.size, 0);\n                            rotate(PI/2);\n                            arrow(item.type);\n                            pop();\n                        }\n                    } else if (item.type === \"time\") {\n                        blendMode(NORMAL);\n                        stroke(0);\n                        fill(255);\n                        ellipse(config.size / 2, config.size / 2, 40, 40);\n                        line(config.size / 2, config.size / 2 + 2, config.size / 2 - 7, config.size / 2 - 5);\n                        line(config.size / 2, config.size / 2 + 2, config.size / 2 + 10, config.size / 2 - 9);\n                    }\n                }\n\n                let esc = cell.escalator;\n                if (esc) {\n                    stroke(0, 0, 255);\n                    const x1 = config.size / 2;\n                    const y1 = config.size / 2;\n                    const x2 = config.size / 2 + (esc.x - i) * config.size;\n                    const y2 = config.size / 2 + (esc.y - j) * config.size;\n                    line(x1, y1, x2, y2);\n                }\n\n                // Draw walls\n                blendMode(NORMAL);\n                if (cell.walls.top) {\n                    stroke(0);\n                    if (cell.walls.top === 'orange') stroke(config.colors['orange']);\n                    line(0, 0, config.size, 0);\n                }\n                if (cell.walls.right) {\n                    stroke(0);\n                    if (cell.walls.right === 'orange') stroke(config.colors['orange']);\n                    line(config.size, 0, config.size, config.size);\n                }\n                if (cell.walls.bottom) {\n                    stroke(0);\n                    if (cell.walls.bottom === 'orange') stroke(config.colors['orange']);\n                    line(0, config.size, config.size, config.size);\n                }\n                if (cell.walls.left) {\n                    stroke(0);\n                    if (cell.walls.left === 'orange') stroke(config.colors['orange']);\n                    line(0, 0, 0, config.size);\n                }\n\n                pop();\n            }\n        }\n    }\n}\n\nclass Cell {\n    constructor(x, y) {\n        this.coord = {\n            x: x,\n            y: y\n        };\n        this.walls = {};\n\n        // Build generic outer walls\n        this.walls.top = (y === 0 && x !== 2);\n        this.walls.right = (x === 3 && y !== 2);\n        this.walls.bottom = (y === 3 && x !== 1);\n        this.walls.left = (x === 0 && y !== 1);\n\n        this.item = false;\n        this.escalator = false;\n    }\n}\n\n/**\n* Draw background grid\n*/\nfunction grid() {\n    for (let i = 0; i < 4; i += 1) {\n        for (let j = 0; j < 4; j += 1) {\n            push();\n            translate(i * config.size, j * config.size);\n\n            // Draw cell\n            stroke(240);\n            rect(0, 0, config.size, config.size);\n\n            pop();\n        }\n    }\n}\n\n/**\n* Draw an arrow\n* @param  {string} type gate, enter\n*/\nfunction arrow(type) {\n    if (type === 'gate') {\n        // Linear arrow\n        blendMode(NORMAL);\n        line(config.size/2, config.size/4, config.size/2, config.size/1.5);\n        line(config.size/2, config.size/4, config.size/3, config.size/2.5);\n        line(config.size/2, config.size/4, config.size/1.5, config.size/2.5);\n        blendMode(MULTIPLY);\n    } else if (type === 'enter') {\n        // Filled arrow\n        strokeJoin(ROUND);\n        strokeCap(ROUND);\n        stroke(150);\n        blendMode(NORMAL);\n        fill(255);\n        beginShape();\n        vertex(config.size/2.25, config.size/3);\n        vertex(config.size/2.25, config.size/4);\n        vertex(config.size/1.7, config.size/4);\n        vertex(config.size/1.7, config.size/3);\n        vertex(config.size/1.5, config.size/3);\n        vertex(config.size/1.93, config.size/2);\n        vertex(config.size/2.75, config.size/3);\n        vertex(config.size/2.75, config.size/3);\n        endShape(CLOSE);\n    } else if (type === 'exit') {\n        // Linear arrow with rectangle\n        strokeJoin(ROUND);\n        strokeCap(ROUND);\n        blendMode(NORMAL);\n        line(config.size/2, config.size/2, config.size/2, config.size/1.4);\n        line(config.size/2, config.size/2, config.size/2 - 10, config.size/1.7);\n        line(config.size/2, config.size/2, config.size/2 + 10, config.size/1.7);\n        rect(config.size/2 - 15, config.size/2 - 25, 30, 15);\n    }\n}\n\n/**\n* Draw a star\n* @param  {int} x  X coordinate\n* @param  {int} y  Y coordinate\n* @param  {int} r1 inner radius\n* @param  {int} r2 outer radius\n* @param  {int} n  points (branches)\n*/\nfunction star(x, y, r1, r2, n) {\n    var angle = TWO_PI / n;\n    beginShape();\n    for (let a = TWO_PI / (-n * 4); a <= TWO_PI; a += angle) {\n        let sx = x + cos(a) * r2;\n        let sy = y + sin(a) * r2;\n        vertex(sx, sy);\n        sx = x + cos(a + angle / 2) * r1;\n        sy = y + sin(a + angle / 2) * r1;\n        vertex(sx, sy);\n    }\n    endShape(CLOSE);\n}\n\n/**\n* Draw a polygon\n* @param  {int} x X coordinate\n* @param  {int} y Y coordinate\n* @param  {int} r radius\n* @param  {int} n points (sides)\n*/\nfunction polygon(x, y, r, n) {\n    let angle = TWO_PI / n;\n    beginShape();\n\n    for (let a = 0; a < TWO_PI; a += angle) {\n        let sx = x + cos(a) * r;\n        let sy = y + sin(a) * r;\n        vertex(sx, sy);\n    }\n    endShape(CLOSE);\n}\n\n/**\n* Get hovered cell coordinates\n* @return {Object} position {x, y}\n*/\nfunction getHoveredCell() {\n    const x = floor((2 * config.size + mouseX - width / 2) / config.size);\n    const y = floor((2 * config.size + mouseY - width / 2) / config.size);\n\n    if (x < 0 || x > 3 || y < 0 || y > 3) {\n        return false;\n    }\n\n    return {x: x, y: y}\n}\n\n/**\n* Get closest side of cell\n* @return {string|bool}  top, bottom, left, right or false\n*/\nfunction getHoveredSide() {\n    let side = false;\n    const x = (mouseX - width / 2 + config.size * 2) % config.size;\n    const y = (mouseY - width / 2 + config.size * 2) % config.size;\n\n    // Detect closest side of cell\n    if (x < config.size / config.tolerance) {\n        side = 'left';\n    } else if (config.size - x < config.size / config.tolerance) {\n        side = 'right';\n    }\n\n    if (y < config.size / config.tolerance) {\n        side = 'top';\n    } else if (config.size - y < config.size / config.tolerance) {\n        side = 'bottom';\n    }\n\n    return side;\n}\n\n/**\n* Clear tile and restore default\n*/\nfunction clearTile() {\n    for (let j = 0; j < 4; j += 1) {\n        for (let i = 0; i < 4; i += 1) {\n            const cell = tile.layout[i][j];\n\n            // Remove all walls\n            cell.walls = {\n                'top': false,\n                'right': false,\n                'bottom': false,\n                'left': false\n            }\n\n            // Restore generic walls\n            cell.walls.top = (j === 0 && i !== 2);\n            cell.walls.right = (i === 3 && j !== 2);\n            cell.walls.bottom = (j === 3 && i !== 1);\n            cell.walls.left = (i === 0 && j !== 1);\n\n            // Remove item and escalator\n            cell.item = false;\n            cell.escalator = false;\n        }\n    }\n}\n\n/**\n* Randomize tile walls and items\n*/\nfunction randomize() {\n    clearTile();\n    for (let j = 0; j < 4; j += 1) {\n        for (let i = 0; i < 4; i += 1) {\n            const cell = tile.layout[i][j];\n\n            // Randomize all walls\n            // cell.walls = {\n            //     'top': Math.random() < .5 ? true : false,\n            //     'right': Math.random() < .5 ? true : false,\n            //     'bottom': Math.random() < .5 ? true : false,\n            //     'left': Math.random() < .5 ? true : false\n            // }\n        }\n    }\n}\n\n/**\n* Save canvas as a 600*600 JPG image\n*/\nfunction exportImage() {\n    let jpg = createGraphics(600, 600);\n    jpg.image(canvas, -70, -70, 740, 740);\n    save(jpg, 'tile.jpg');\n}\n\n/**\n* Export tile as a compressed string\n*/\nfunction exportString() {\n    const string = jsonToString(tileToJson(tile));\n    console.log(string);\n}\n\n/**\n* Convert tile data to JSON\n* @return {Object}  JSON\n*/\nfunction tileToJson() {\n    let json = {};\n\n    for (let i = 0; i < 4; i += 1) {\n        json[i] = {};\n\n        for (let j = 0; j < 4; j += 1) {\n            json[i][j] = {};\n            json[i][j].walls = {};\n\n            json[i][j].walls.top = tile.layout[j][i].walls.top;\n            json[i][j].walls.right = tile.layout[j][i].walls.right;\n            json[i][j].walls.bottom = tile.layout[j][i].walls.bottom;\n            json[i][j].walls.left = tile.layout[j][i].walls.left;\n\n            json[i][j]['item'] = tile.layout[j][i].item;\n            json[i][j]['escalator'] = tile.layout[j][i].escalator;\n        }\n    }\n\n    return json;\n}\n\n/**\n* Convert tile json to compressed string\n* @param  {Object} json tile data\n* @return {string}      string\n*/\nfunction jsonToString(tile) {\n    // 64 characters\n    let string = '';\n\n    for (let x = 0; x < 4; x += 1) {\n        for (let y = 0; y < 4; y += 1) {\n\n            // Cell object\n            const cell = tile[x][y];\n\n            // 4 characters\n            let block = '';\n\n            // Walls\n            let base3 = '';\n            for (let wall of ['top', 'right', 'bottom', 'left']) {\n                if (cell.walls[wall] === 'orange') {\n                    base3 += 2;\n                } else if (cell.walls[wall]) {\n                    base3 += 1;\n                } else {\n                    base3 += 0;\n                }\n            }\n            block += parseInt(base3, 3);\n            block = block.length === 1 ? '0' + block : block;\n\n            // Item\n            let item = '0';\n\n            if (cell.item) {\n                if (cell.item.color) {\n                    let id = {\n                        'gate': 1,\n                        'vortex': 5,\n                        'article': 9,\n                        'exit': 13\n                    }[cell.item.type];\n\n                    id += ['green', 'orange', 'purple', 'yellow'].indexOf(cell.item.color);\n\n                    // Convert to base-36\n                    item = id.toString(36);\n                } else {\n                    item = {\n                        'enter': 'h',\n                        'time': 'i',\n                        'crystal': 'j',\n                        'camera': 'k'\n                    }[cell.item.type];\n                }\n            }\n            block += item;\n\n            // Escalator\n            let escalator = '0';\n\n            if (cell.escalator) {\n                escalator = cell.escalator.x * 4 + cell.escalator.y + 1;\n\n                // Convert to base-36\n                escalator = escalator.toString(36);\n            }\n            block += escalator;\n            string += block;\n        }\n    }\n\n    return string;\n}\n\n/**\n* General click actions\n*/\n\n$(document).on('click', 'ul li', (e) => {\n    const $el = $(e.currentTarget);\n\n    if ($el.attr('data-color')) {\n        color = $el.attr('data-color');\n    } else if ($el.attr('data-tool')) {\n        tool = $el.attr('data-tool');\n    }\n\n    updateUI();\n});\n\n$(document).on('click', 'button[name=\"clear\"]', () => {\n    clearTile();\n});\n\n$(document).on('click', 'button[name=\"random\"]', () => {\n    randomize();\n});\n\n$(document).on('click', 'button[name=\"export\"]', () => {\n    exportImage();\n    exportString();\n});\n\n/**\n* General key press actions\n* @param {Object} e event\n*/\nfunction keyPressed(e) {\n    if (keyIsDown(49)) { // 1\n        tool = 'wall';\n    } else if (keyIsDown(50)) { // 2\n        tool = 'wall-orange';\n    } else if (keyIsDown(51)) { // 3\n        tool = 'enter';\n    } else if (keyIsDown(52)) { // 4\n        tool = 'gate';\n    } else if (keyIsDown(53)) { // 5\n        tool = 'vortex';\n    } else if (keyIsDown(54)) { // 6\n        tool = 'article';\n    } else if (keyIsDown(55)) { // 7\n        tool = 'exit';\n    } else if (keyIsDown(56)) { // 8\n        tool = 'time';\n    } else if (keyIsDown(57)) { // 9\n        tool = 'escalator';\n    } else if (keyIsDown(71)) { // G\n        color = 'green';\n    } else if (keyIsDown(79)) { // O\n        color = 'orange';\n    } else if (keyIsDown(80)) { // P\n        color = 'purple';\n    } else if (keyIsDown(89)) { // Y\n        color = 'yellow';\n    }\n\n    updateUI();\n}\n\n/**\n* Update UI elements (tools and colors selectors)\n*/\nfunction updateUI() {\n    $('ul.tools').find('li.selected').removeClass('selected');\n    $('ul.tools').find('li[data-tool=\"' + tool + '\"]').addClass('selected');\n\n    $('ul.colors').find('li.selected').removeClass('selected');\n    $('ul.colors').find('li[data-color=\"' + color + '\"]').addClass('selected');\n\n    if (tool === 'gate' || tool === 'vortex' || tool === 'exit' || tool === 'article') {\n        $('.colors').css('opacity', 1);\n    } else {\n        $('.colors').css('opacity', 0);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/client/create/js/main.js?");

/***/ })

/******/ });